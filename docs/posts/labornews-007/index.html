<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="박영삼">
<meta name="dcterms.date" content="2023-06-23">

<title>외환위기 이후 소득격차, 개인 간 줄고 가구 간 악화 – Labor &amp; Society</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Labor &amp; Society</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://facebook.com"> <i class="bi bi-facebook" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://yspark1968.blogspot.com/"> 
<span class="menu-text">Blogger</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">외환위기 이후 소득격차, 개인 간 줄고 가구 간 악화</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">소득불평등</div>
                <div class="quarto-category">외환위기</div>
                <div class="quarto-category">노동패널</div>
                <div class="quarto-category">사회이동성</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>박영삼 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 23, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#외환위기-이후-소득격차-개인-간-줄고-가구-간-악화" id="toc-외환위기-이후-소득격차-개인-간-줄고-가구-간-악화" class="nav-link active" data-scroll-target="#외환위기-이후-소득격차-개인-간-줄고-가구-간-악화">외환위기 이후 소득격차, 개인 간 줄고 가구 간 악화</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="박영삼의-통계로-보는-노동" class="level4">
<h4 class="anchored" data-anchor-id="박영삼의-통계로-보는-노동">박영삼의 통계로 보는 노동</h4>
</section>
<section id="외환위기-이후-소득격차-개인-간-줄고-가구-간-악화" class="level2">
<h2 class="anchored" data-anchor-id="외환위기-이후-소득격차-개인-간-줄고-가구-간-악화">외환위기 이후 소득격차, 개인 간 줄고 가구 간 악화</h2>
<section id="한국노동패널-분석-결과-취업자-많은-고소득-가구-자산-이익도-몰려" class="level4">
<h4 class="anchored" data-anchor-id="한국노동패널-분석-결과-취업자-많은-고소득-가구-자산-이익도-몰려">한국노동패널 분석 결과 … 취업자 많은 고소득 가구, 자산 이익도 몰려</h4>
<p>997년 말 외환위기가 발발한 지 벌써 25년이라는 세월이 흘렀다. 외환위기는 대한민국 역사에서 경제적 측면의 가장 큰 환란이었다. 고도성장 성공 신화에 취해 세계화를 향해 달리던 재벌 대기업들의 무리한 차입경영과 확장투자가 국가부도 사태까지 몰고 왔다. 갑자기 들이닥친 달러 기근 상황을 해결하기 위해 온 국민들이 고금리·긴축재정·대량해고·구조조정을 감당해야 했다.</p>
<p>그 이후 25년은 한 세대에 걸친 시간이다. 그 시절을 온몸으로 겪었던 중년 노동자는 이제 황혼을 맞았고, 그때 태어났던 아이는 성인이 됐다. 그리고 당시 중·고교에 다니던 청소년들은 이제 40대 초·중반의 나이가 됐다.</p>
<p>이 시기의 변화를 고스란히 담고 있는 단일한 통계자료가 한국노동연구원의 노동패널이다. 한국노동패널은 우리나라의 개인과 가구의 생애에 걸친 변화를 추적하기 위해 1998년에 처음으로 구축돼 올해로 25년째를 맞고 있다. 1998년 첫 조사 때 5천가구(가구원수 1만3천319명)가 표본으로 선정돼 이 중에서 2021년까지 24년간 조사가 지속된 가구는 3천161가구(가구원수 1만1천838명)다. ’98통합표본’으로 불리는데 이들은 제주도를 제외한 도시가구들을 대표하는 표본이다. 여기에 2009년과 2018년에 새로운 표본을 추가해서 전국의 일반가구를 모두 포괄하게 됐는데, 1998년 이후 전 기간을 동일가중치로 확인하기 위해서는 원표본만 대상으로 분석하기로 한다. 표본의 마모가 심한 단점이 있기는 하지만 전 기간을 볼 수 있다는 점에서 의미를 찾을 수 있다. 분석에는 한국노동연구원이 패널데이터 원자료와 함께 제공하는 가구 연간총소득분위(세후)를 기준으로 활용했다.</p>
<section id="고소득-가구-소득집값-가파른-상승" class="level5">
<h5 class="anchored" data-anchor-id="고소득-가구-소득집값-가파른-상승">고소득 가구, 소득·집값 가파른 상승</h5>
<p>1998년 당시 우리나라 취업자 2천835만명의 개인 월평균 소득은 117만원이었다. 자영업자까지 포함한 수치다. 이러던 개인소득이 2021년에는 288만원으로 2.5배로 상승했다. 2008년 금융위기 이전까지는 개인소득 격차가 확대되는 시기였다. 그러나 2008년 금융위기 이후 개인소득 격차와 불평등은 점차 감소추세를 보였다.</p>
<p>하지만 가구소득의 방향은 이와는 달랐다. 2012년 이후에도 상위 20%의 소득증가는 지속됐고 격차는 계속 확대됐다. 1998년 이후 가구소득은 1천765만원에서 6천195만원으로 3.5배나 올랐다. 고소득 가구의 소득이 훨씬 크게 증가했기 때문이다. 결과는 가구소득 격차 확대다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption>개인소득과 가구소득</figcaption>
<p><img src="20241107_030124.jpg" class="img-fluid figure-img"></p>
</figure>
</div>
<p>코로나 이후 개인소득과 가계소득 불평등 모두 증가한 것으로 나타나는데 가구소득 불평등 급등은 상위 20% 가구의 부동산소득 증가가 미친 영향도 크다. 2021년 상위 10%의 부동산소득(양도소득 포함)은 연평균 1천211만원에 달했다. 평균소득 대비 주택가격 배율은 2000년 3.9배에서 2021년 6.8배로 급등했다. 상위 20% 가구가 소유한 주택가격이 가장 크게 올랐다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption>소득분위별 주택가격</figcaption>
<p><img src="20241107_030317.jpg" class="img-fluid figure-img"></p>
</figure>
</div>
<p>이처럼 최근 다시 개인소득과 가구소득의 불평등 흐름이 강화되고 있는 것에 대해 노동패널 원자료는 다음 두 가지 사실을 주목하게 한다.</p>
<p>첫째, 소득이 발생하는 취업자의 전반적인 구성이 상위소득 가구로 집중되고 있다는 점이다. 25년 전 외환위기 때는 취업가구원의 절반 이상(54.4%)이 소득 3분위 이하 가구의 구성원들이었다. 그러던 것이 2010년이 되면 3분위 이하 가구의 취업자 비중은 41.5%로 떨어지며, 2021년에는 취업자의 42,6%가 상위 20% 가구에 속한 것으로 나타난다. 분석에서 사용한 분위가 비균등화 세후총소득 기준이기 때문에 가구규모를 통제하지 않은 데 따른 영향도 있다. 하지만 1분위 가구의 가구원 비중은 13%이지만 취업자 비중은 4%에 불과하며 5분위 가구의 가구원 비중은 35%인데 반해 취업자 비중은 43%에 이른다. 그리고 이 갭은 해마다 계속 커지고 있다.</p>
</section>
<section id="저소득층에겐-비혼이-결과이자-원인" class="level5">
<h5 class="anchored" data-anchor-id="저소득층에겐-비혼이-결과이자-원인">저소득층에겐 ’비혼’이 결과이자 원인</h5>
<p>고령화로 인해 가구원이 적은 노인가구가 늘어나고 있는 것도 이유가 될 수 있지만, 청·장년들조차 일자리 접근성과 가구형성 여력이 전반적으로 하락하고 있다는 점을 주의해서 볼 필요가 있다.</p>
<p>1998년 외환위기 당시 15~19세이던 청소년들은 1979년부터 1983년까지 출생한 세대로 이른바 MZ세대의 제일 선두에 해당한다. 노동패널에는 1천448명이 포함돼 있다. 이들 중 2021년까지 조사에 참여한 가구원은 688명이었다. 고려대 노동문제연구소에서는 이들에 대해 소득분위별로 취업·결혼·실업 등과 같은 주요 생애사건의 확률과 평균 빈도를 계산했다. 취업의 경우 전 기간에 걸친 취업확률은 51%로 나타났다. 상위 20% 가구원은 56%인 반면 하위 20%의 취업확률은 38%로 크게 낮았다. 2021년 기준 취업률은 상위 20%는 89%에 이르는 반면 하위 20%의 취업률은 27%에 불과했다. 실업횟수는 하위 20% 가구 소속은 평균 0.8회를 경험한 것으로 나타났으나 상위 20% 가구원은 0.39로 훨씬 낮았다.</p>
<p>한편 결혼 비율은 상위 20%가 74%에 이르는 반면, 소득분위 순으로 4분위 53%, 3분위 55%, 2분위 38%를 나타냈다. 경제적 요인 때문에 결혼에 어려움을 겪지만 단독가구로 남게 되면 경제적 어려움을 더 크게 겪게 된다.</p>
<p>청소년기에 IMF 환란을 맞았던 이들 중에서 하위 40% 가구에 속한 비율은 33.9%였다. 하지만 2021년 현재 성인이 된 그들 중 하위 40% 가구에 남아 있는 비율은 11.0%에 불과하다. 새로운 가구를 구성하거나 독립하면서 처지를 개선했기 때문이다. 하지만 빈곤의 위험에 직면해 있는 다수의 어른과 새로운 어린 세대, 그리고 혼자로 남아 있는 IMF 키즈들이 여전히 있다. 그들에게는 지금이 25년 전 그때의 상황과 크게 다르지 않을지도 모른다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption>외횐위기 이후 청소년들의 변화</figcaption>
<p><img src="215777_93151_5548.jpg" class="img-fluid figure-img"></p>
</figure>
</div>
<p>고려대 노동문제연구소 노동데이터센터장 (<a href="youngsampk@gmail.com">youngsampk@gmail.com</a>)<br>
</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>