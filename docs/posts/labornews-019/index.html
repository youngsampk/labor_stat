<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="박영삼">
<meta name="dcterms.date" content="2024-03-15">

<title>“근로소득자 5명 중 1명 종합소득 신고” – Labor &amp; Stat</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Labor &amp; Stat</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://facebook.com"> <i class="bi bi-facebook" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://yspark1968.blogspot.com/"> 
<span class="menu-text">Blogger</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">“근로소득자 5명 중 1명 종합소득 신고”</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">국세통계</div>
                <div class="quarto-category">소득신고</div>
                <div class="quarto-category">소득분배</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>박영삼 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 15, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#근로소득자-5명-중-1명-종합소득-신고" id="toc-근로소득자-5명-중-1명-종합소득-신고" class="nav-link active" data-scroll-target="#근로소득자-5명-중-1명-종합소득-신고">“근로소득자 5명 중 1명 종합소득 신고”</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="박영삼의-통계로-보는-노동" class="level4">
<h4 class="anchored" data-anchor-id="박영삼의-통계로-보는-노동">박영삼의 통계로 보는 노동</h4>
</section>
<section id="근로소득자-5명-중-1명-종합소득-신고" class="level2">
<h2 class="anchored" data-anchor-id="근로소득자-5명-중-1명-종합소득-신고">“근로소득자 5명 중 1명 종합소득 신고”</h2>
<section id="통합소득-천분위-분석-결과-2017년-이전-수준으로-돌아간-소득분배" class="level4">
<h4 class="anchored" data-anchor-id="통합소득-천분위-분석-결과-2017년-이전-수준으로-돌아간-소득분배">통합소득 천분위 분석 결과 … 2017년 이전 수준으로 돌아간 소득분배</h4>
<p>국세청에 신고한 최신 개인소득 통계들이 공개되고 있다. 국세청이 근로소득 연말정산과 종합소득 확정신고 결과를 집계한 통계를 공개했고, 2월부터는 국회에 제출한 소득 천분위 자료 분석 결과들이 공개되고 있다. 이 글에서 분석한 자료는 기존에 공개된 2012~2021년 자료에 최근 국세청이 윤건영 더불어민주당 의원실에 제출한 통합소득과 근로소득, 종합소득 천분위 자료를 추가한 것이다.</p>
<p>국세청 소득신고 자료는 소득이 발생한 다음해 5월에 확정 신고하고 정산 및 환급 과정을 거쳐 그 해 연말에 가서야 공식 집계된다. 최근 공개된 소득통계는 2022년 귀속분 소득자료다.</p>
<p>한편 소득천분위 자료는 소득순으로 백분위를 구분한 다음 최상위 1%는 0.1% 구간으로 10개의 구간을 세분해 집계한 것을 말한다. 통합소득 천분위 자료는 근로소득이 있으면서 사업소득이나 이자배당소득, 기타소득 등이 발생해 종합소득까지 신고하는 인원에 대해 중복을 제거하고 개인별로 합산한 것을 말한다. 그러므로 통합소득 천분위 자료는 우리나라의 임금노동자와 자영업자, 프리랜서 등의 신고소득을 개인 단위로 통합한 자료라고 볼 수 있다. 다만 2천만원 미만 이자배당소득 등 분리과세하는 소득은 제외된다.</p>
<section id="고소득층은-추가소득-늘어나고-저소득층도-작은-일거리-찾아-나서" class="level5">
<h5 class="anchored" data-anchor-id="고소득층은-추가소득-늘어나고-저소득층도-작은-일거리-찾아-나서">고소득층은 추가소득 늘어나고, 저소득층도 작은 일거리 찾아 나서</h5>
<p>2022년 우리나라의 근로소득 연말정산 인원은 2천54만명으로 처음으로 2천만명을 돌파했다. 그리고 종합소득 확정신고 인원은 1천28만명으로 역시 처음으로 1천만명을 넘겼다. 그런데 근로소득과 종합소득 모두 신고하는 중복인원이 458만명에 달해 통합소득 인원은 2천623만명으로 최종 집계됐다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="220422_97729_2900.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>최근 눈에 띄는 중요한 변화는 근로소득과 종합소득신고 모두 신고하는 사람들의 뚜렷한 증가 추세다. 2012년에 112만명 수준이던 중복신고 인원은 2020년에 276만명으로 늘어났고 2021년에는 394만명으로 1년 사이에 117만명이나 늘었다. 2022년에도 64만명이 다시 늘어 458만명 규모로 늘었다. 같은 기간 근로소득만 신고하는 인원은 2020년 1천673만명에서 2021년 1천602만명, 2022년 1천596만명으로 오히려 71만명, 6만명씩 줄어든 것과 대조를 보인다. 종합소득만 신고하는 인원도 매년 30만명 규모로 늘었지만 근로소득과 종합소득 모두 신고하는 인원의 증가폭은 이를 훨씬 넘어서는 규모다. 전체 근로소득자 5명 중 1명 이상이 종합소득신고를 병행하고 있고, 종합소득신고자의 절반가량이 근로소득이 있는 사람들이다.</p>
<p>상위소득자 가운데 기타소득이나 금융소득이 있는 사람들이 늘어나고 있고, 하위소득자 중에서도 플랫폼노동을 비롯한 여러 가지 일을 병행해야 하는 ’N잡러’가 늘어나는 상황을 반영하고 있는 것으로 볼 수 있다. 국세청의 신고절차 간소화와 소득파악률 개선 영향도 있다.</p>
<p>어쨌든 이같은 소득신고 유형이 다양화되는 상황에서 전체적인 개인소득 분배상황을 제대로 파악하기 위해서는 근로소득만이 아니라 종합소득 신고분까지 포함한 통합소득의 분포를 살펴보는 것이 점점 더 필요해지고 있다.</p>
<p>2022년 통합소득 기준 상위 10%의 평균소득은 1억5천179만원이었고 상위 5%는 2억947만원이며, 상위 1%에 속하는 26만명의 평균소득은 4억7천931만원이었다. 최상위 0.1%의 평균소득은 17억9천641만원에 달했다. 반면 하위 40%와 하위 20%의 평균소득은 991만원과 429만원에 불과했다. 근로소득 천분위 분석 결과와 비교하면 상위층의 평균소득은 근로소득보다 더 높아지고 하위층의 평균소득은 근로소득보다 더 낮아진다. 소득 분산이 더 커지는 것이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="220422_97730_2901.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>그런데 소득 10분위 소득증가율을 보면 2018년에는 소득이 가장 낮은 1분위와 최저임금 수준과 소득수준이 유사한 4분위의 소득증가율이 각각 7.6%, 7.9%로 가장 높았고 가장 소득이 높은 10분위가 2.1%로 가장 낮은 증가율을 기록했다. 반면 2020년 코로나 사태 때는 이와 정반대로 1분위의 소득증가율이 5.2%를 기록했고 10분위는 3.4%로 가장 높은 소득증가율을 보였다. 2022년에는 1~10분위의 소득증가율이 3~5% 수준에서 비슷한 증가율을 보였는데, 2022년의 소비자물가 상승률 5.1%를 감안하면 실질소득은 감소한 셈이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="220422_97731_2901.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>코로나 사태를 맞아 악화한 소득분배 상황은 좀처럼 개선되지 못하고 있다. 상위 10%가 전체소득에서 차지하는 비중은 37.6%로 코로나 사태 이후 가장 나빴던 2021년의 37.8%에 비해서는 0.2%포인트 감소했지만 2019년의 36.6%에 비해서는 1.1%포인트 증가한 것으로 2017년 이전 수준으로 돌아간 상황이다. 상위 0.1%, 1%, 5%의 소득점유율도 각각 4.5%, 11.9% 26.0%로 2021년에 비해서는 조금씩 하락했지만 2019년보다는 모두 늘어 상위계층의 소득점유는 더 늘어난 상태다.</p>
<p>한편 2017년 이후 2019년까지 2년 연속 크게 개선됐던 소득분배 지표 역시 2016년 이전 수준으로 후퇴했다. 하위 10% 소득대비 상위 10%의 소득배율을 뜻하는 10분위배율은 2019년에 64.0배로 역대 최저를 기록했지만 2022년에는 71.2배로 2015년 이전 수준으로 되돌아갔고, 하위 20% 대비 상위 20% 소득배율을 의미하는 5분위배율도 25.6배로 2016년 이전 수준으로 상승했다. 하위 40% 대비 상위 10%의 소득배율을 나타내는 팔마비율(3.83배)도 2016년 이전 수준을 보인다. 지니계수도 2022년에 0.518을 기록해 2018년 이전 수준과 비슷하다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="220422_97732_4510.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>상위소득층은 계속 추가적인 소득을 얻고 있고 하위소득층은 그나마 적은 소득을 얻기 위해 다양한 일거리를 찾아 나서고 있다. 하지만 경제적 충격을 받은 이후 악화한 분배상황은 개선되지 못하고 있다. 이것이 통합소득 천분위 자료를 통해 확인할 수 있는 코로나 사태 이후 소득의 분배 양상이다.</p>
<p>고려대 노동문제연구소 노동데이터센터장 (<a href="youngsampk@gmail.com">youngsampk@gmail.com</a>)<br>
</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>