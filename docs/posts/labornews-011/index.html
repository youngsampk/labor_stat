<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="박영삼">
<meta name="dcterms.date" content="2023-07-07">

<title>한국 의사 임금 간호사의 3.7배, 임금격차 OECD 1위 – Labor &amp; Society</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Labor &amp; Society</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://facebook.com"> <i class="bi bi-facebook" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://yspark1968.blogspot.com/"> 
<span class="menu-text">Blogger</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">한국 의사 임금 간호사의 3.7배, 임금격차 OECD 1위</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">의사 연봉</div>
                <div class="quarto-category">간호사</div>
                <div class="quarto-category">OECD</div>
                <div class="quarto-category">보건통계</div>
                <div class="quarto-category">의사 부족</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>박영삼 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 7, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#한국-의사-임금-간호사의-3.7배-임금격차-oecd-1위" id="toc-한국-의사-임금-간호사의-3.7배-임금격차-oecd-1위" class="nav-link active" data-scroll-target="#한국-의사-임금-간호사의-3.7배-임금격차-oecd-1위">한국 의사 임금 간호사의 3.7배, 임금격차 OECD 1위</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="박영삼의-통계로-보는-노동" class="level4">
<h4 class="anchored" data-anchor-id="박영삼의-통계로-보는-노동">박영삼의 통계로 보는 노동</h4>
</section>
<section id="한국-의사-임금-간호사의-3.7배-임금격차-oecd-1위" class="level2">
<h2 class="anchored" data-anchor-id="한국-의사-임금-간호사의-3.7배-임금격차-oecd-1위">한국 의사 임금 간호사의 3.7배, 임금격차 OECD 1위</h2>
<section id="모든-기준-따져-봐도-한국-의사-압도적-고임금-국내-간호사일반-노동자-대비-격차도-확대" class="level4">
<h4 class="anchored" data-anchor-id="모든-기준-따져-봐도-한국-의사-압도적-고임금-국내-간호사일반-노동자-대비-격차도-확대">모든 기준 따져 봐도 한국 의사 압도적 ‘고임금’ … 국내 간호사·일반 노동자 대비 격차도 확대</h4>
<p><img src="216597_93842_3454.jpg" class="img-fluid"></p>
<p>지난달 30일 국내 언론이 우리나라 전문의 급여가 OECD 회원국 가운데 가장 높다고 보도했다. 경제협력개발기구(OECD) 자료에 따르면 우리나라 병원에 고용돼 월급을 받는 봉직의(페이닥터)의 임금은 구매력 평가(PPP) 기준 미국 달러 환율로 표시할 경우 19만2천749달러로 자료를 제출한 28개국 중 1위를 차지했다. 한국 다음으로 의사 급여가 높은 나라는 네덜란드(19만1천482달러)였고, 3위는 독일(18만7천715달러)이었다. 한편 사업소득으로 집계하는 개원의 보수는 7개국에서 자료를 제출했는데 한국은 29만8천800달러로 벨기에(30만1천814달러) 다음으로 2위를 기록했다.</p>
<section id="구매력-평가ppp-기준만-문제-아니다" class="level5">
<h5 class="anchored" data-anchor-id="구매력-평가ppp-기준만-문제-아니다">구매력 평가(PPP) 기준만 문제 아니다</h5>
<p>OECD 보건통계는 의사를 전문의와 일반의로 구분하고 있으며, 개원의와 봉직의 급여를 따로 각각 집계한다. 보수 금액은 자국 통화와 미달러 시장환율, 구매력 평가 기준이 모두 나와 있다. 4가지 유형의 의사 급여를 3개 기준으로 작성하는 것이다. 한국 정부가 보고한 2020년 전문의 보수는 봉직의 임금이 1억8천930만원이었고 개원의 보수는 2억9천345만원이었다. 시장환율(2020년 원달러 환율 1천180.3원)을 적용할 경우 전문의 중 봉직의와 개원의 급여는 각각 16만387달러, 24만8천632달러였다. 봉직의 급여는 28개국 중 7위, 개원의 사업소득은 7개국 중 3위였다. 구매력 평가 환율은 2020년 1달러당 982.1원으로 평가됐다. 이를 적용하면 봉직의 임금이 19만2천749달러, 개원의 보수가 29만8천800달러로 한국이 각각 1위, 2위가 된 것이다.</p>
<p>이런 이유 때문인지 대한의사협회 산하 의료정책연구원은 구매력 평가 환율을 적용한 OECD 통계가 잘못됐다고 반박에 나섰다. 하지만 구매력 평가 기준은 임금과 소득 관련 국제비교에서 일반적으로 사용된다. 그리고 구매력 평가 기준이든 시장환율 기준이든, 봉직의든 개원의든 한국 의사급여의 증가세는 회원국 가운데 압도적으로 높다. OECD 보건통계에는 2010년 이후 데이터가 모두 수록돼 있다. 2020년까지 10년 동안 한국 의사의 임금은 구매력 평가 기준으로 2010년 13만6천104달러에서 2020년 19만2천749달러로 10년 동안 42% 상승했다. 하지만 시장환율 기준으로는 10만6천908달러에서 2020년 16만387달러로 50.0%나 증가했다. OECD평균 대비 한국의 의사 급여는 구매력 평가 기준으로 1.53배에서 1.71배로 높아진 반면, 시장환율 기준으로는 1.09배에서 1.60배로 상승폭이 훨씬 더 크다. 개원의 보수도 구매력 평가 기준으로는 63.4% 올랐고 시장환율 기준으로는 73.1%나 상승했다. 모든 면에서 한국 의사의 수입이 다른 국가들에 비해 큰 폭으로 급등했다고 볼 수밖에 없다.</p>
</section>
<section id="의사-나-홀로-임금-급상승" class="level5">
<h5 class="anchored" data-anchor-id="의사-나-홀로-임금-급상승">의사 ‘나 홀로’ 임금 급상승</h5>
<p>그렇다면 한국 의사의 보수 증가가 우리나라 1인당 국내총생산(GDP)이나 한국 노동자들의 전반적인 임금 상승에 따른 자연스러운 결과일까. 결코 그렇지 않다. 1인당 GDP 대비로는 2010년 4.63배였던 전문의 급여는 2020년 5.06배로 훨씬 더 높아졌다. 전체 노동자 평균임금 대비로도 같은 기간 4.02배에서 4.40배로 역시 더 크게 격차를 벌려 놓았다. 개원의의 경우 6.22배에서 7.84배로, 노동자 평균임금 대비로는 5.40배에서 6.83배로 훨씬 더 격차가 크다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="20241107_051419.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>의사협회는 또한 이 같은 의사 임금 증가가 단지 의료산업의 팽창 때문이라고 말하고 싶을지 모른다. 하지만 같은 기간 한국 간호사의 임금은 의사들만큼 오르지 않았다. OECD 통계상으로 2010년 1인당 GDP 대비 1.36배이던 간호사의 임금(4만98달러)은 2020년에도 1.36배 수준(5만2천33달러) 그대로다. OECD 순위로는 14위에 해당한다. 노동자 평균임금 대비 간호사 임금은 2010년 1,18배에서 2020년 1.19배로 거의 변화가 없다. 회원국 중 15위에 해당한다. 간호사의 임금은 1인당 GDP와 전체 노동자 임금상승만큼 증가했다.</p>
<p>결과적으로 간호사 임금 대비 의사의 임금만 더 높아진 것이다. 2010년 한국 간호사 대비 전문의 의사의 임금수준은 3.39배였다. 이것이 2020년에는 3.70배로 더 벌어졌다. 이 기간 OECD 평균은 2010년 2.43배에서 2020년 2.27배로 격차가 줄어들고 있었다. 한국은 2020년 기준 간호사와 의사의 임금격차가 가장 큰 나라가 됐다.</p>
</section>
<section id="의료비-지출-증가-이익은-자본의사에-집중" class="level5">
<h5 class="anchored" data-anchor-id="의료비-지출-증가-이익은-자본의사에-집중">의료비 지출 증가, 이익은 자본·의사에 집중</h5>
<p>우리나라의 경상의료비 지출은 2010년에는 GDP의 5.9%인 78조3천억원에서 2021년에는 180조6천억원(GDP의 8.8%)으로 두 배 이상 늘었다. 가계의 의료지출과 국가의 건강보험 지출이 모두 늘었기 때문이고, 고령화와 1인당 의료비지출 증가가 동반된 결과다. 여기에 우리나라는 1인당 의사에 대한 외래진료 횟수가 가장 많고 인구 대비 MRI와 CT 장비 보유대수가 가장 많은 나라다. 인구 대비 병상수와 평균 입원일수도 세계 1위다.</p>
<p>한편 같은 기간 임상간호사수는 22만8천614명에서 45만3천864명으로 99% 증가했고 간호학과 연간 졸업자수는 4만2천861명에서 5만4천429명으로 26% 늘었다. 하지만 의사들의 상황은 전혀 다르다. 2010~2021년 동안 임상의사수는 9만8천293명에서 13만2479명으로 35% 증가하는데 그쳤고, 인구 10만명당 연간 의대 졸업자수는 2010년 8.13명에서 2021년 7.26명으로 오히려 줄어들었다. G20 국가 중 인구 대비 의대 졸업자수가 감소한 나라는 한국이 유일했다. 심지어 우리나라와 의사 비율이 비슷한 이스라엘·일본·캐나다·미국조차도 의대 졸업자수를 크게 늘려 왔는데 한국은 정반대 모습을 보이고 있다. 늘어나는 의료지출은 병원을 비롯한 의료산업의 매출증가로 이어지지만 그 이익은 자본과 의사에게로 집중된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<figcaption>인구 10만명당 의대졸업자 수(OECD)</figcaption>
<p><img src="20241107_051453.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>이런 현상은 의사의 장시간 노동과 짧은 환자당 진료시간, 과열된 의대입시와 왜곡된 노동시장을 불렀다. 하지만 의료산업 부문에서 노동조합은 간호사를 비롯한 의료인력의 증원을 요구해 왔고 의사협회는 의사인력 증원에 반대하고 있다. 누가 공공성을 추구하고 누가 담합과 카르텔에 집착하고 있는지 분명하지만, 정부는 엉뚱한 곳에서 공격대상을 찾는 것을 멈추지 않고 있다.</p>
<p>고려대 노동문제연구소 노동데이터센터장 (<a href="youngsampk@gmail.com">youngsampk@gmail.com</a>)<br>
</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>