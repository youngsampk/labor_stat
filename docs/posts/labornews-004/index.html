<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="박영삼">
<meta name="dcterms.date" content="2023-05-12">

<title>올바른 복지재원 마련 ‘부자 증세’ 35%, ‘국민 모두’ 32% – Labor &amp; Statistics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Labor &amp; Statistics</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://facebook.com"> <i class="bi bi-facebook" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://yspark1968.blogspot.com/"> 
<span class="menu-text">Blogger</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">올바른 복지재원 마련 ‘부자 증세’ 35%, ‘국민 모두’ 32%</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">복지정책</div>
                <div class="quarto-category">복지인식</div>
                <div class="quarto-category">증세</div>
                <div class="quarto-category">복지패널</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>박영삼 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 12, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#올바른-복지재원-마련-부자-증세-35-국민-모두-32" id="toc-올바른-복지재원-마련-부자-증세-35-국민-모두-32" class="nav-link active" data-scroll-target="#올바른-복지재원-마련-부자-증세-35-국민-모두-32">올바른 복지재원 마련 ‘부자 증세’ 35%, ‘국민 모두’ 32%</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="박영삼의-통계로-보는-노동" class="level4">
<h4 class="anchored" data-anchor-id="박영삼의-통계로-보는-노동">박영삼의 통계로 보는 노동</h4>
</section>
<section id="올바른-복지재원-마련-부자-증세-35-국민-모두-32" class="level2">
<h2 class="anchored" data-anchor-id="올바른-복지재원-마련-부자-증세-35-국민-모두-32">올바른 복지재원 마련 ‘부자 증세’ 35%, ‘국민 모두’ 32%</h2>
<section id="복지패널-부가조사-원자료20162022-분석-인식-격차-줄었지만-소득계층-이해는-분명" class="level4">
<h4 class="anchored" data-anchor-id="복지패널-부가조사-원자료20162022-분석-인식-격차-줄었지만-소득계층-이해는-분명">복지패널 부가조사 원자료(2016~2022) 분석 … 인식 격차 줄었지만 소득계층 이해는 분명</h4>
<p>지난달 7일 한국복지패널 원자료가 일반에 공개됐다. 복지패널은 한국노동연구원의 노동패널과 함께 우리나라의 대표적인 패널조사로 보건사회연구원과 서울대 사회복지연구소가 2006년부터 구축해 오고 있다. 빈곤층 실태를 충실하게 파악하고 정부의 복지정책 수립에 활용하기 위해 저소득층 표본가구를 조사대상에 충분히 포함하면서 가중치를 부여해 전체 가구를 대표하도록 하고 있다.</p>
<p>이번에 발표된 17차 조사는 지난해 3월부터 7월까지 실시된 것으로 모두 8천169가구 조사가 완료된 것으로 보고됐다. 보건사회연구원은 해마다 이 자료를 공개하면서 해당 연도의 조사결과 기초분석보고서를 발간하는데, 최근 ‘복지인식 부가조사’ 결과를 다룬 언론보도들이 주목을 끌었다.</p>
<p>주요한 내용으로는 성장과 분배 가운데 어느 것이 더 중요하냐는 질문에 성장이 중요하다는 의견이 52%, 분배가 더 중요하다는 의견이 48%로 성장 쪽이 약간 우세했다. 경제를 살리기 위해 세금을 줄여야 한다는 의견에는 동의(35%)가 반대(26%)보다 많았으나 중립(39%) 의견이 가장 많았다. 반대로 복지를 위해 세금을 늘려야 한다는 입장에 대해서도 찬성(32%)이 반대(31%)를 근소하게 앞섰지만 가장 높은 비율은 중립(37%) 의견이 차지했다.</p>
<section id="년-부가조사-분석-동일-가구-패널조사로-인식-변화-추적" class="level5">
<h5 class="anchored" data-anchor-id="년-부가조사-분석-동일-가구-패널조사로-인식-변화-추적">2016·2019·2022년 부가조사 분석<br> 동일 가구 패널조사로 인식 변화 추적</h5>
<p>그런데 패널조사는 동일한 가구와 가구원을 대상으로 반복적으로 추적조사를 하는 것이기 때문에 한 해의 조사결과만 보기보다는 과거 조사결과와 비교해 보는 것이 필요하다. 그리고 이것이 패널조사의 장점이기도 하다. 복지패널의 복지인식 부가조사는 3년마다 실시하고 있다. 2022년 부가조사는 2016·2019년 부가조사 대상에 포함됐던 5천996가구의 가구원 2천829명을 대상으로 최종 완료됐다. 이에 복지패널 원자료를 가지고 가장 최근의 3차례에 걸친 복지인식 부가조사 결과를 분석하고 어떤 변화가 있었는지 그 흐름을 추적해 봤다.</p>
<p>우선 성장과 분배에 대해서 어느 것이 더 중요한지에 대한 응답은 2013년 조사에서는 50:50으로 동일했던 것이 2019년에 52:48로 성장 쪽으로 약간 기울었고, 2022년에도 그대로 유지됐다. 일반가구와 저소득가구(균등화중위소득의 60%이하 가구)로 구분해서 보면, 같은 기간 두 그룹 모두 성장만이 중요하다거나 분배만이 중요하다는 응답은 감소하고 성장이나 분배가 상대적으로 중요하다는 중간 의견 쪽으로 이동한 것으로 나타난다. 대신 저소득가구에서는 분배가 상대적으로 더 중요하다는 의견이 43%에서 50%로 늘어난 반면, 일반가구에서 성장이 더 중요하다는 입장이 41%에서 49%로 크게 강화된 것으로 나타난다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="215040_92368_4113.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</section>
<section id="성장vs분배-의견차-줄고-증세감세-반대의견-동시-감소" class="level5">
<h5 class="anchored" data-anchor-id="성장vs분배-의견차-줄고-증세감세-반대의견-동시-감소">성장vs분배 의견차 줄고, 증세·감세 반대의견 동시 감소</h5>
<p>사회복지를 확대하려면 세금을 더 거둬야 한다는 의견에 대해서는 찬성 비율이 크게 달라지지는 않았으나(32%→33%→31%), 반대 비율이 다소 줄어든 것(35%→33%→31%)으로 나타났다. 이러한 증세 반대 의견 약화는 저소득가구와 일반가구에 공통적으로 나타났다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="215040_92369_4113.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>한편 경제를 살리기 위해서는 세금을 줄여야 한다는 정반대 의견에 대한 응답도 크게 다르지는 않았다. 동의 비율이 30% 초·중반을 횡보하는(33%→37%→35%) 모습을 보이는 가운데 반대 비율이 약간 감소하는 양상을 보였다. 증세도 감세도 적당한 수준에서 중간 의견이 지배하고 있는 상황이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="215040_92370_4113.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>통계적으로 유의한 차이와 변화를 보인 항목은 보편복지와 선별복지에 대한 의견을 묻는 항목이었다. 국가가 복지정책을 펼 때 모든 국민을 대상으로 하는 방안과 가난한 사람만을 대상으로 하는 방안 중 어떤 것이 옳으냐는 질문에 대해 ‘모든 국민’을 대상으로 하는 방안이 옳다는 의견이 2016년 21%에서 2022년에는 30%로 크게 증가했다. 대신 가난한 사람들만을 대상으로 하는 것이 옳다는 의견은 79%에서 70% 수준으로 줄어들었다. 세부적으로는 2016년 가장 큰 비중을 차지했던 ‘소득하위 50%’와 ‘소득하위 30%’ 대상이 옳다는 의견은 각각 2%포인트(27%→25%), 4%포인트(22%→18%) 줄었다. ’소득하위 70%’까지 대상으로 해야 한다는 의견만 15%에서 19%에서 늘었다. 복지대상을 대체로 넓혀야 한다는 쪽으로 의견이 이동한 것이다.</p>
</section>
<section id="저소득층은-빈곤층-지원집중-일반가구는-모든-국민-지원" class="level5">
<h5 class="anchored" data-anchor-id="저소득층은-빈곤층-지원집중-일반가구는-모든-국민-지원">저소득층은 “빈곤층 지원집중” 일반가구는 “모든 국민 지원”</h5>
<p>하지만 이것은 일반 가구가 다수를 차지하는 상황을 반영하는 것일 뿐 저소득 가구의 경우에는 전 국민 대상 복지가 옳다는 의견이 2016년 15%에서 2019년 26%로 크게 늘었다가 2022년에 오히려 17% 수준으로 크게 줄어들었다. 소득하위 50%(25%→34%)와 소득하위 70%(11%→18%) 대상이 옳다는 의견이 강화된 것으로 나타난다. 이것은 문재인 정부 시기 기초생활보장이나 근로장려세제의 확대나 코로나 위기 당시 정부지원금 지급 등의 복지수급 경험이 반영된 것으로 보인다. 일반가구에서는 동일한 경험을 해도 복지혜택이 일부에게만 가서는 안 된다는 인식을 갖게 된 반면, 저소득가구는 어려운 사람들에게 좀 더 두텁게 지원해 주는 것이 옳다고 느끼게 된 것으로 이해된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="215040_92371_4114.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>그렇다면 정작 복지에 필요한 재원의 조달에 대해서는 어떤 의견들을 가지고 있고 변화는 어땠을까? 이번 2022년 조사에서 고소득층의 세금 부담이 낮다는 의견은 59%에 달했다. 상당한 국민이 고소득층이 제대로 세금을 내지 않고 있다고 보는 것이다. 하지만 2016년에는 이 의견이 82%에 달했을 정도였으니 많이 완화한 것이다. 반면 중간층의 세금 부담이 낮다는 응답은 6년 전 17%에서 8% 수준으로 줄어들었으며, 저소득층의 세금 부담이 낮다는 의견은 8%에서 12%로 오히려 늘었다. 소득계층에 따른 조세부담 정도에 대한 인식차이가 있지만 한편으로는 그 차이가 좁혀지고 있는 측면을 보여준다. 이와 관련해서 복지패널 부가조사에서는 “노인, 아동, 장애인 등을 위한 복지재원을 어떻게 마련하는 것이 가장 바람직한가”라고 물었는데 2016년에는 부자(44%), 기업(22%), 모든 국민(21%) 순이었다. 그러나 2022년에는 부자(35%), 모든 국민(32%), 기업(23%) 순으로 바뀌었다. 수혜자 부담으로 해결해야 한다는 응답은 9%에서 6%로 줄었다.</p>
</section>
<section id="국민-모두가-부담해야-10p-늘어상위-20-부담-회피-경향도-커져" class="level5">
<h5 class="anchored" data-anchor-id="국민-모두가-부담해야-10p-늘어상위-20-부담-회피-경향도-커져">“국민 모두가 부담해야” 10%p 늘어…상위 20% 부담 회피 경향도 커져</h5>
<p>이 항목의 경우 소득분위에 따른 차이가 큰 것으로 나타났다. 상위 20%에 해당하는 5분위 가구원들은 부자들의 세금으로 조달해야 한다는 의견이 대폭 줄고(41%→30%) 국민 모두의 세금으로 해결해야 한다는 응답이 2배(21%→41%) 가까이 늘었다. 4분위 이하의 가구원들은 모든 국민의 부담으로 해결해야 한다는 응답이 약 10% 정도는 늘어난 것으로 나타났다. 다만 기업들의 세금으로 마련해야 한다는 응답 비율은 크게 변화가 없었다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="215040_92372_4114.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>복지패널 부가조사 결과는 복합적인 사실을 말해 준다. 6년 전에 비해 고소득층과 저소득층의 복지인식에 간극이 줄어든 측면도 있지만 일부에서는 방향이 더 벌어진 것도 있다.</p>
<p>성장이나 분배 어느 한 쪽만 중요하다는가, 복지에 필요한 재원을 특정 계층의 부담으로 모두 해결해야 한다든가 하는 문제에 관한 견해는 계층 간 차이가 크게 줄어든 것으로 나타난다. 양극단의 사고는 피하고 중도에 가까운 인식변화를 보이고 있는 것이 눈에 띈다. 부담·수혜의 대상과 범위를 좀 더 넓고 고르게 하는 것이 좋다는 흐름이 읽혀진다.</p>
<p>하지만 여전히 차이가 크고 변화 방향이 완전히 다른 대목도 확인할 수 있다. 가난한 사람은 정부의 역할과 분배의 중요성이 더 커졌다고 보고 있고 더 어렵고 힘든 사람들을 제대로 도와야 한다고 생각하는 반면, 고소득층은 자신들의 부담이 더 무거워지는 것을 피하고자 한다. 이것은 문재인 정부 시기 복지 확대와 더불어 코로나 위기 극복 과정에서의 복지경험을 통해 얻은 각자의 교훈이기도 하고, 앞으로 발생할 수 있는 잠재된 갈등 요소이기도 하다.</p>
<p>고려대 노동문제연구소 노동데이터센터장 (<a href="youngsampk@gmail.com">youngsampk@gmail.com</a>)<br>
</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>